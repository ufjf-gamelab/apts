@startuml class_diagram_base
title Class diagram: Game, State and Move

hide empty members

!function $type($name)
!return "struct " + $name + " << (T,lavender) >>"
!endfunction

!function $type($name, $generics)
!return "struct " + $name + $generics + " << (T,lavender) >>"
!endfunction

package Types << rectangle >> {

  package Standard << rectangle >>{
    $type(number)
    $type(string)
    $type(boolean)
  }

  package Aliases << rectangle >> {

    $type(Integer)
    Integer [alias] ..> number

    $type(Char)
    Char [alias] ..> string

  }

}

package player_package as "Player" {

    package Aliases << rectangle >> {

    $type(IndexOfPlayer)
    IndexOfPlayer [alias] ..> Integer

  }

  interface ParamsOfPlayer {
    name: string
    symbol: Char
  }

  abstract class Player {
    - name: ParamsOfPlayer::name
    - symbol: ParamsOfPlayer::symbol
    --
    + getName(): this::name
    + getSymbol(): this::symbol
  }
  Player::name -> ParamsOfPlayer::name
  Player::symbol -> ParamsOfPlayer::symbol

}

package slot_package as "Slot" {

    package Aliases << rectangle >> {

    $type(IndexOfSlot)
    IndexOfSlot [alias] ..> Integer

  }

  interface ParamsOfSlot {}

  abstract class Slot {
    + {static} getSlot({indexOfSlot: IndexOfSlot; slots: Slot[];}): null | Slot
  }

}

package move_package as "Move" {

    package Aliases << rectangle >> {

    $type(IndexOfMove)
    IndexOfMove [alias] ..> Integer

  }

  interface ParamsOfMove {
    title: string
    description: string
  }

  abstract class Move {
    - title: ParamsOfMove::title
    - description: ParamsOfMove::description
    --
    + getTitle(): this::title
    + getDescription(): this::description
  }
  Move::title -> ParamsOfMove::title
  Move::description -> ParamsOfMove::description

}

package game_package as "Game" {

  interface ParamsOfGame {
    moves: Move[]
    name: string
    players: Player[]
    quantityOfSlots: Integer
  }
  ParamsOfGame::players --> Player
  ParamsOfGame::moves --> Move

  abstract class Game {
    - moves: ParamsOfGame::moves
    - name: ParamsOfGame::name
    - players: ParamsOfGame::players
    - quantityOfSlots: ParamsOfGame::quantityOfSlots
    --
    + getMove(indexOfMove: IndexOfMove): null | Move
    + getMoves(): this::moves
    + getName(): this::name
    + getPlayer(indexOfPlayer: IndexOfPlayer): null | Player
    + getPlayers(): this::players
    + getQuantityOfMoves(): Integer
    + getQuantityOfPlayers(): Integer
    + getQuantityOfSlots(): this::quantityOfSlots
    .. abstract ..
    + {abstract} getIndexOfNextPlayer(state: State): IndexOfPlayer
    + {abstract} getInitialState(): State
    + {abstract} getValidMoves(state: State): Move[]
    + {abstract} isFinal(state: State): boolean
    + {abstract} play(indexOfMove: IndexOfMove, state: State): State
  }
  Game::moves -> ParamsOfGame::moves
  Game::name -> ParamsOfGame::name
  Game::players -> ParamsOfGame::players
  Game::quantityOfSlots -> ParamsOfGame::quantityOfSlots
  
}

package state_package as "State" {

  package Aliases << rectangle >> {

    $type(Points)
    Points [alias] ..> Integer

  }

  $type(Score) {
    Array<Points>
  }
  Score::0 --> Points

  interface ParamsOfState {
    game: Game
    indexOfPlayer: IndexOfPlayer
    score: Score
    slots: Slot[]
  }
  ParamsOfState::game --> Game
  ParamsOfState::indexOfPlayer --> IndexOfPlayer
  ParamsOfState::score --> Score
  ParamsOfState::slots --> Slot

  abstract class State {
    # game: ParamsOfState::game
    # indexOfPlayer: ParamsOfState::indexOfPlayer
    # score: ParamsOfState::score
    # slots: ParamsOfState::slots
    --
    + getGame(): this::game
    + getIndexOfPlayer(): this::indexOfPlayer
    + getQuantityOfSlots(): Integer
    + getScore(): this::score
    + getSlot(indexOfSlot: IndexOfSlot): null | Slot
    + getSlots(): this::slots
  }
  State::game -> ParamsOfState::game
  State::indexOfPlayer -> ParamsOfState::indexOfPlayer
  State::score -> ParamsOfState::score
  State::slots -> ParamsOfState::slots

}


@enduml
